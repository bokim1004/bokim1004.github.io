{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/usecallback_usememo/","result":{"data":{"site":{"siteMetadata":{"title":"프론트엔드 로그 by 굥 🐳","author":"굥","siteUrl":"https://bokim1004.github.io","comment":{"disqusShortName":"https-bokim1004-github-io","utterances":"bokim1004/blog-comments"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"352ed303-c07e-5a47-be96-5b8dc99c709b","excerpt":"useCallback과 useMemo는 리액트로 개발할 때 성능 최적화를 위해 많이 사용되는 hook이다.\n이것에 대한 정확한 특징과 차이점을 더 자세히 알기 위해 공부를 해보았다. useCallback과 useMemo에 대해 파고들기 전 먼저 알아둘 점 함수형 컴포넌트는 그냥 함수다. 단지 jsx…","html":"<p>useCallback과 useMemo는 리액트로 개발할 때 성능 최적화를 위해 많이 사용되는 hook이다.\n이것에 대한 정확한 특징과 차이점을 더 자세히 알기 위해 공부를 해보았다.</p>\n<h3 id=\"usecallback과-usememo에-대해-파고들기-전-먼저-알아둘-점\" style=\"position:relative;\"><a href=\"#usecallback%EA%B3%BC-usememo%EC%97%90-%EB%8C%80%ED%95%B4-%ED%8C%8C%EA%B3%A0%EB%93%A4%EA%B8%B0-%EC%A0%84-%EB%A8%BC%EC%A0%80-%EC%95%8C%EC%95%84%EB%91%98-%EC%A0%90\" aria-label=\"usecallback과 usememo에 대해 파고들기 전 먼저 알아둘 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback과 useMemo에 대해 파고들기 전 먼저 알아둘 점</h3>\n<ol>\n<li>\n<p>함수형 컴포넌트는 그냥 함수다. 단지 jsx를 반환하는 함수라는 것을 먼저 알아야 한다.<br/>\n컴포넌트가 렌더링된다는 것은 누군가가 그 함수(컴포넌트)를 호출하여서 실행되는 것을 말한다. 함수가 실행될 때마다 내부에 선언되어있던 표현식(변수,또 다른 함수 등)도 매번 다시 선언되어 사용된다. <br/></p>\n</li>\n<li>\n<p>컴포넌트는 자신의 state가 변경되거나, 부모에게서 받는 props가 변경되었을 때마다 리렌더링된다.( 하위 컴포넌트에 최적화 설정을 해주지 않으면 부모에게서 받는 props가 변경되지 않았더라도 리렌더링 되는게 기본이다) <br/></p>\n</li>\n<li>\n<p><code class=\"language-text\">memoization</code>은 무언가를 기억하는 것이다. <br/></p>\n</li>\n<li>\n<p><code class=\"language-text\">useMemo</code>와 <code class=\"language-text\">useCallback</code>은 한마디로 dependancies가 변경될 때까지 렌더 시 무언가를 기억하는 것이다. <span style=\"background-color:yellow\">차이점은 무언가를 기억하느냐이다.</span><br/></p>\n</li>\n<li>\n<p><code class=\"language-text\">useMemo</code>는 함수에서 리턴(반환)된 value를 기억하는 것이다.<br/></p>\n</li>\n<li>\n<p><code class=\"language-text\">useCallback</code>은 실제 함수를 기억하는 것이다.<br/></p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fn</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span><span class=\"token number\">42</span>  <span class=\"token operator\">/</span> <span class=\"token operator\">/</span> assuming expensive calculation here\n<span class=\"token keyword\">const</span> memoFn <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>dep<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// (1)</span>\n<span class=\"token keyword\">const</span> memoFnReturn <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>dep<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//(2)</span></code></pre></div>\n<p>(1)은 memoized된 버전인 fn을 리턴할 것이다. memoFn함수를 invoke할 때마다, 복잡한 computation이 다시 시작된다.<br/>\n(2)는 dep이 변경될 때마다 fn을 invoke할 것이고 리턴된 value를 기억할 것이다. 이 value(42)는 memoFnReturn에 저장될 것이다.</p>\n<h3 id=\"usememo\" style=\"position:relative;\"><a href=\"#usememo\" aria-label=\"usememo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo?</h3>\n<p><code class=\"language-text\">메모이제이션된 값을 반환한다</code>라는 문장이 핵심이다. <br/>\n하위 컴포넌트에서 상위컴포넌트로부터 props를 전달 받는다. 하위 컴포넌트에서는 props를 전달 받으면 서로 다른 함수로 각각의 값을 가공한 새로운 값을 보여주는 역할을 한다.<br/>\n하위 컴포넌트는 props로 넘겨받는 인자가 하나라도 변경될 때마다 렌더링되는데 props.a만 변경되었을 때 이전과 같은 값인 props.b도 다시 함수를 호출해서 재계산해야할까? 그냥 이전에 계산된 값을 쓰면 되는데~!</p>\n<p><code class=\"language-text\">useMemo를 사용하면 의존성 배열에 넘겨준 값이 변경되었을 때만 메모이제이션된 값을 다시 계산한다.</code></p>\n<h4 id=\"usememo를-왜-사용하고-언제-사용하는가\" style=\"position:relative;\"><a href=\"#usememo%EB%A5%BC-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"usememo를 왜 사용하고 언제 사용하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo를 왜 사용하고 언제 사용하는가?</h4>\n<p>초기렌더에 useMemo를 사용하면 더 expensive하지만 그 다음 리렌더시에는 훨씬 큰 성능 향상을 가져다 준다.\n만약, application의 data/processing 복잡도가 5000이상이거나 리렌더가 되는 경우가 있다면, useMemo를 사용하는 것이 이득이다.</p>\n<p>useMemo는 불필요한 리렌더를 피할 때 유용하다.</p>\n<h3 id=\"usecallback\" style=\"position:relative;\"><a href=\"#usecallback\" aria-label=\"usecallback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback?</h3>\n<p><code class=\"language-text\">메모이제이션된 함수를 반환한다</code>라는 문장이 핵심이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> onChangeHandler <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span> <span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>id <span class=\"token operator\">===</span>“color”<span class=\"token punctuation\">)</span> <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">else</span> <span class=\"token function\">setMovie</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>이벤트 핸들러 함수나 api를 요청하는 함수를 주로 useCallback으로 선언하는 코드가 많다.<br/>\n하지만, 비싼 계산이 아니라면 useMemo사용을 권장하지 않는 것처럼 함수 재선언을 막기 위해 useCallback을 사용하는 것도 크게 의미있어 보이지는 않는다.<br/>\n만약 하위 컴포넌트가 React.memo()같은 것으로 최적화되어있고 그 하위 컴포넌트에게 callback함수를 props로 넘길 때, 상위 컴포넌트에서 useCallback으로 함수를 선언하는 것이 유용하다라는 의미다.</p>\n<h4 id=\"usecallback은-어떤-상황에서-필요한가\" style=\"position:relative;\"><a href=\"#usecallback%EC%9D%80-%EC%96%B4%EB%96%A4-%EC%83%81%ED%99%A9%EC%97%90%EC%84%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\" aria-label=\"usecallback은 어떤 상황에서 필요한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback은 어떤 상황에서 필요한가?</h4>\n<p>컴포넌트가 렌더링될 때마다 새로운 함수를 생성해서 자식 컴포넌트의 속성값으로 입력하는 경우가 많다.<br/>\n리액트 팀에서는 최근의 브라우저에서 함수 생성이 성능에 미치는 영향은 작다고 주장한다. <br/>\n그보다는 속성값이 매번 변경되기에 자식 컴포넌트에서 React.memo를 사용해도 불필요한 렌더링이 발생한다는 문제점이 있다.<br/>\n리액트에서는 이 문제를 해결하기 위해 <code class=\"language-text\">useCallback</code>훅을 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">' react'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> saveToServer <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./api'</span>\n<span class=\"token keyword\">import</span> UserEdit <span class=\"token keyword\">from</span> <span class=\"token string\">'./UserEdit'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Profile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">,</span> setName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>age<span class=\"token punctuation\">,</span> setAge<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">age is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>UserEdit\n        onSave<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">saveToServer</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n        setName<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>setName<span class=\"token punctuation\">}</span>\n        setAge<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>setAge<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드를 보면 Profile 컴포넌트가 렌더링될때마다 UserEdit컴포넌트의 onSave속성값으로 새로운 함수가 입력된다.\n따라서 UserEdit컴포넌트에서 React.memo를 사용해도 onSave속성값이 항상 변경되고 그 때문에 불필요한 렌더링이 발생된다.\nonSave속성값은 name이나 age값이 변경되지 않으면 항상 같아야 한다.\nuseCallback 훅을 사용하면 불필요한 렌더링을 막을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Profile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">,</span> setName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>age<span class=\"token punctuation\">,</span> setAge<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">const</span> onSave <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">saveToServer</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">age is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>UserEdit onSave<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onSave<span class=\"token punctuation\">}</span> setName<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>setName<span class=\"token punctuation\">}</span> setAge<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>setAge<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>useCallback훅의 두번째 매개변수는 의존성 배열이다. 의존성 배열이 변경되지 않으면 이전에 생성한 함수가 재사용된다.\n따라서 name과 age값이 변경되지 않으면,UserEdit컴포넌트의 onSave속성값으로 항상 같은 함수가 전달된다.</p>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<p><code class=\"language-text\">useMemo</code> 는 특정 결과값을 재사용 할 때 사용하는 반면, <code class=\"language-text\">useCallback</code> 은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용한다.</p>\n<blockquote>\n<p>참고 : 실전 리액트 프로그래밍</p>\n</blockquote>","frontmatter":{"title":"useCallback과 useMemo 차이점","date":"August 08, 2022","image":"https://velog.velcdn.com/images/chloeee/post/ed085f44-d352-47d3-a184-280a757804b7/image.png"}}},"pageContext":{"slug":"/react/usecallback_usememo/","previous":{"fields":{"slug":"/react/react_hooks/"},"frontmatter":{"title":"리액트 훅스의 클로저 트랩 (Closure Trap) 이해하기(번역)"}},"next":{"fields":{"slug":"/react/recoil_-react를-위한-상태관리-라이브러리/"},"frontmatter":{"title":"react를 위한 상태관리 라이브러리 Recoil"}}}},"staticQueryHashes":["2486386679","3128451518"]}