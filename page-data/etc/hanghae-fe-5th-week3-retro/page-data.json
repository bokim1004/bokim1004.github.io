{"componentChunkName":"component---src-templates-blog-post-js","path":"/etc/hanghae-fe-5th-week3-retro/","result":{"data":{"site":{"siteMetadata":{"title":"프론트엔드 기록 by chloee 🐳","author":"chloee","siteUrl":"https://bokim1004.github.io","comment":{"disqusShortName":"https-bokim1004-github-io","utterances":"bokim1004/blog-comments"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"2de7249d-ee3d-59c9-9294-80d6d4622743","excerpt":"들어가며 3주차 과제는 hook을 직접 구현해보며, 동작원리를 살펴보는 시간을 가졌다. 내가 몰랐던 부분들을 알게 되는 과정이 재밌었던 시간이었다. ✨과제 셀프회고 이번 과제를 통해 내가 궁극적으로 얻고 싶었던 것은 Hook을 직접 구현해보며 동작을 제대로 이해해 보는 것이었다.\n,,를 실무에서 사용해봤으나 제대로 사용해서 성능 최적화를 하고 있나에 대한 의문이 많았다.\nHook…","html":"<h3 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h3>\n<p>3주차 과제는 hook을 직접 구현해보며, 동작원리를 살펴보는 시간을 가졌다. 내가 몰랐던 부분들을 알게 되는 과정이 재밌었던 시간이었다.</p>\n<h2 id=\"과제-셀프회고\" style=\"position:relative;\"><a href=\"#%EA%B3%BC%EC%A0%9C-%EC%85%80%ED%94%84%ED%9A%8C%EA%B3%A0\" aria-label=\"과제 셀프회고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✨과제 셀프회고</h2>\n<p>이번 과제를 통해 내가 궁극적으로 얻고 싶었던 것은 Hook을 직접 구현해보며 동작을 제대로 이해해 보는 것이었다.\n<code class=\"language-text\">React.memo</code>,<code class=\"language-text\">useCallback</code>,<code class=\"language-text\">useMemo</code>를 실무에서 사용해봤으나 제대로 사용해서 성능 최적화를 하고 있나에 대한 의문이 많았다.\nHook을 직접 구현해보며 어떻게 동작하는건지 정말 많은 부분 알게 되고 이해하게 된 것들이 많다.</p>\n<h3 id=\"-과제를-하며-새로-알게된-부분\" style=\"position:relative;\"><a href=\"#-%EA%B3%BC%EC%A0%9C%EB%A5%BC-%ED%95%98%EB%A9%B0-%EC%83%88%EB%A1%9C-%EC%95%8C%EA%B2%8C%EB%90%9C-%EB%B6%80%EB%B6%84\" aria-label=\" 과제를 하며 새로 알게된 부분 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥰 과제를 하며 새로 알게된 부분</h3>\n<hr>\n<h3 id=\"1-hook을-구현하려면-얕은비교-깊은비교를-먼저-알아야-한다\" style=\"position:relative;\"><a href=\"#1-hook%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%95%EC%9D%80%EB%B9%84%EA%B5%90-%EA%B9%8A%EC%9D%80%EB%B9%84%EA%B5%90%EB%A5%BC-%EB%A8%BC%EC%A0%80-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"1 hook을 구현하려면 얕은비교 깊은비교를 먼저 알아야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Hook을 구현하려면 얕은비교, 깊은비교를 먼저 알아야 한다</h3>\n<p>성능 최적화를 한다고 Hook을 사용했을 때, 얕은 비교와 깊은 비교에 대해 부끄럽지만 크게 생각해본 적이 없다.\n얕은 비교,깊은 비교는 어떻게 되는 것인지 살펴보았다.</p>\n<h4 id=\"얕은-비교란\" style=\"position:relative;\"><a href=\"#%EC%96%95%EC%9D%80-%EB%B9%84%EA%B5%90%EB%9E%80\" aria-label=\"얕은 비교란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>얕은 비교란?</h4>\n<p>객체나 배열 등의 참조형 데이터를 비교할 때, <code class=\"language-text\">속성 값의 내부까지 보지 않고, 참조(주소)만 비교</code>하는 방식이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'보경'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'보경'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\na <span class=\"token operator\">===</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// false (얕은 비교)</span></code></pre></div>\n<p><code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>는 내용은 같지만 서로 다른 객체이기 때문에 <code class=\"language-text\">===</code> 비교에서는 false다.</p>\n<h4 id=\"깊은-비교란\" style=\"position:relative;\"><a href=\"#%EA%B9%8A%EC%9D%80-%EB%B9%84%EA%B5%90%EB%9E%80\" aria-label=\"깊은 비교란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>깊은 비교란?</h4>\n<p>객체의 <code class=\"language-text\">내부 속성들까지 전부 재귀적으로 비교</code>해서 진짜 내용이 같은지를 확인하는 방식이다.</p>\n<blockquote>\n<p><code class=\"language-text\">왜 재귀적 호출이 필요할까?</code></p>\n</blockquote>\n<p>깊은 비교라는 건 단순히 겉모습이 아니라, 값의 내부구조까지 전부같은지 확인하는 것.\n근데 이 내부구조는 또 객체나 배열일 수도 있다.  그래서 그런 내부 구조를 다시 비교하려면, 계속해서 안으로 파고들어서 자기 자신을 반복호출(재귀)하는것이다.</p>\n<h4 id=\"-hooks사용-시-비교가-왜-중요할까\" style=\"position:relative;\"><a href=\"#-hooks%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EB%B9%84%EA%B5%90%EA%B0%80-%EC%99%9C-%EC%A4%91%EC%9A%94%ED%95%A0%EA%B9%8C\" aria-label=\" hooks사용 시 비교가 왜 중요할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧠 Hooks사용 시, 비교가 왜 중요할까?</h4>\n<p>리액트에서 훅스(<code class=\"language-text\">useEffect</code>, <code class=\"language-text\">useMemo</code>, <code class=\"language-text\">useCallback</code> 등)는 종속성 배열을 기반으로 작동한다.\nuseEffect코드를 예로 보면,</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Check changes'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>user<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 <code class=\"language-text\">user</code> 객체가 바뀌었는지를 리액트는 <strong>얕은 비교</strong>로 판단한다. 즉, <code class=\"language-text\">user</code>의 속성 값이 같더라도, 새로운 객체로 생성됐다면 <strong>변경된 걸로 간주</strong>된다.</p>\n<h4 id=\"-얕은-비교에는-단점이-존재한다\" style=\"position:relative;\"><a href=\"#-%EC%96%95%EC%9D%80-%EB%B9%84%EA%B5%90%EC%97%90%EB%8A%94-%EB%8B%A8%EC%A0%90%EC%9D%B4-%EC%A1%B4%EC%9E%AC%ED%95%9C%EB%8B%A4\" aria-label=\" 얕은 비교에는 단점이 존재한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💥 얕은 비교에는 단점이 존재한다</h4>\n<p>만약 매 렌더마다 새로운 객체가 만들어지면 (불변성을 지키지 않거나 useMemo등을 안 쓰면) 훅이 <strong>쓸데없이 실행</strong>된다.</p>\n<h4 id=\"-그럼-언제-깊은-비교를-써야-할까\" style=\"position:relative;\"><a href=\"#-%EA%B7%B8%EB%9F%BC-%EC%96%B8%EC%A0%9C-%EA%B9%8A%EC%9D%80-%EB%B9%84%EA%B5%90%EB%A5%BC-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\" 그럼 언제 깊은 비교를 써야 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🔍 그럼 언제 깊은 비교를 써야 할까?</h4>\n<ul>\n<li>객체나 배열의 <strong>내용 자체가 진짜 바뀌었는지를 보고 싶을 때</strong></li>\n<li>혹은 커스텀 훅이나 성능 최적화 상황에서 비교 로직을 세밀하게 제어하고 싶을 때</li>\n</ul>\n<h3 id=\"2-useref는-단지-dom참조를-위한-hook만이-아니다\" style=\"position:relative;\"><a href=\"#2-useref%EB%8A%94-%EB%8B%A8%EC%A7%80-dom%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%9C%84%ED%95%9C-hook%EB%A7%8C%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4\" aria-label=\"2 useref는 단지 dom참조를 위한 hook만이 아니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. useRef는 단지 DOM참조를 위한 Hook만이 아니다</h3>\n<p>실무에서 useRef를 사용했을 때, DOM요소에 직접 접근해야할 때 많이 썼었다.\n단순히 값을 저장하는 용도로 사용한 적이 없었는데 useRef를 직접 구현해보니 이 Hook의 핵심은 컴포넌트가 <code class=\"language-text\">리렌더링되어도 값이 유지되도록 저장</code>하는데 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> useRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>initialValue<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">current</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Lazy Initialization: 최초 렌더 시에만 실행됨</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>ref<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">current</span><span class=\"token operator\">:</span> initialValue <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> ref<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>코드를 살펴보면,ref.current에 initialValue를 저장하고 이 값은 컴포넌트가 리렌더되어도 바뀌지 않고 유지된다.</p>\n<blockquote>\n<p>✅Lazy Initialization이란?</p>\n</blockquote>\n<p><code class=\"language-text\">() => ({ current: initialValue })</code> 이렇게 함수 형태로 전달하면 렌더링 시점에서 바로 계산하지 않고 “필요할 때까지 초기값 계산을 미룬다”\n즉, 지금 바로 값이나 객체를 만들지 않고,<br>\n→ 정말 필요해졌을 때 딱 한 번 만드는 방식!</p>\n<h3 id=\"3-usecallback안에는-usememo가-있다\" style=\"position:relative;\"><a href=\"#3-usecallback%EC%95%88%EC%97%90%EB%8A%94-usememo%EA%B0%80-%EC%9E%88%EB%8B%A4\" aria-label=\"3 usecallback안에는 usememo가 있다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. useCallback안에는 useMemo가 있다</h3>\n<p>useCallback 내부 코드를 살펴보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> DependencyList <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">useCallback</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">Function</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\nfactory<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n_deps<span class=\"token operator\">:</span> DependencyList<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">return</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> factory<span class=\"token punctuation\">,</span> _deps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">useCallback(fn, deps)</code> 는<br>\n“이 함수<code class=\"language-text\">fn</code>를 memoize 해줘, deps 바뀌기 전까진 같은 참조값으로 유지할게” 라는 뜻이다.</li>\n<li>내부적으로는 그냥 <code class=\"language-text\">useMemo(() => fn, deps)</code> 와 완전히 동일하다.\n<ul>\n<li>\n<p><code class=\"language-text\">() => fn</code>은 함수 자체를 리턴하는 <strong>팩토리 함수</strong>다.</p>\n</li>\n<li>\n<p>즉, <code class=\"language-text\">useMemo</code>가 실행되면 → <code class=\"language-text\">fn</code>이라는 <strong>함수 그 자체</strong>가 반환된다.</p>\n</li>\n<li>\n<p><strong>실행되는 게 아니라, 그냥 그 함수 객체를 반환해서 저장해두는 것</strong>이다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>즉, <code class=\"language-text\">useCallback(fn, deps)</code>는 <code class=\"language-text\">useMemo(() => fn, deps)</code>랑 사실상 같은 역할을 한다-!</p>\n<hr>\n<h3 id=\"-과제-트러블-슈팅-과정\" style=\"position:relative;\"><a href=\"#-%EA%B3%BC%EC%A0%9C-%ED%8A%B8%EB%9F%AC%EB%B8%94-%EC%8A%88%ED%8C%85-%EA%B3%BC%EC%A0%95\" aria-label=\" 과제 트러블 슈팅 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥰 과제 트러블 슈팅 과정</h3>\n<h3 id=\"-문제-상황-1-header-컴포넌트가-불필요하게-리렌더링됨\" style=\"position:relative;\"><a href=\"#-%EB%AC%B8%EC%A0%9C-%EC%83%81%ED%99%A9-1-header-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EA%B0%80-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%98%EA%B2%8C-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81%EB%90%A8\" aria-label=\" 문제 상황 1 header 컴포넌트가 불필요하게 리렌더링됨 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧩 문제 상황 1. Header 컴포넌트가 불필요하게 리렌더링됨</h3>\n<p>테스트에서<code class=\"language-text\">it(\"알림 추가 및 닫기시 ComplexForm, NotificationSystem만 리렌더링되어야 한다\",</code> 여기서 Header컴포넌트도 리렌더되는 이슈가 있었다.</p>\n<p><code class=\"language-text\">문제 원인</code>은 관심사 분리를 충분히 세분화하지 않고 context를 사용했던 것에 있었다.</p>\n<h4 id=\"-원인-분석\" style=\"position:relative;\"><a href=\"#-%EC%9B%90%EC%9D%B8-%EB%B6%84%EC%84%9D\" aria-label=\" 원인 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🔍 원인 분석</h4>\n<p>문제는 바로 로그인쪽 상태랑 notification쪽 상태를 하나의 context에 넣어 사용하고 있었던 것이었다.\n기존에는 <code class=\"language-text\">NotificationSystem</code>에서 <code class=\"language-text\">const { notifications, removeNotification }=useAuthContext()</code> 이렇게 값을 꺼내쓰고 있었다.</p>\n<p>➡️ 그래서 notification이 바뀔 때마다 <code class=\"language-text\">useAuthContext()</code>를 사용하는 이 context를 쓰고 있는 Header, NotificationSystem 둘 다 리렌더가 됐던 것이다.</p>\n<blockquote>\n<p>❓<strong>NotificationSystem을 React.memo로 감쌌는데 왜 리렌더될까?</strong></p>\n</blockquote>\n<ul>\n<li><code class=\"language-text\">NotificationSystem</code>을 <code class=\"language-text\">React.memo</code>로 감싸도 <strong>여전히 리렌더되는 이유</strong>는,</li>\n</ul>\n<p>React.memo는 props가 안 바뀌면 리렌더를 막아주는 역할이지만,\ncontext 내부 값이 바뀌면 소용이 없다.\ncontext는 props가 아니라 훅으로 가져오는 것!\n그래서 내부 값이 바뀌면 그걸 쓰는 컴포넌트는 무조건 다시 그려진다.</p>\n<h4 id=\"-해결-방법\" style=\"position:relative;\"><a href=\"#-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" aria-label=\" 해결 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✅ 해결 방법</h4>\n<p>👉 알림 관련 상태만 따로 NotificationContext로 분리했다.\n로그인 관련 상태는 기존처럼 AuthContext에 두고, 알림은 완전히 따로 떼내었다.\n이렇게 관심사를 분리해주니까,\nHeader는 로그인 상태만 보고, NotificationSystem은 알림 상태만 보게 되면서 로 영향받지 않고 리렌더링 문제도 해결이 되었다!</p>\n<h3 id=\"-문제-상황-2generateitems가-2번-호출되는-이슈\" style=\"position:relative;\"><a href=\"#-%EB%AC%B8%EC%A0%9C-%EC%83%81%ED%99%A9-2generateitems%EA%B0%80-2%EB%B2%88-%ED%98%B8%EC%B6%9C%EB%90%98%EB%8A%94-%EC%9D%B4%EC%8A%88\" aria-label=\" 문제 상황 2generateitems가 2번 호출되는 이슈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧩 문제 상황 2.generateItems가 2번 호출되는 이슈</h3>\n<p><code class=\"language-text\">여러 작업을 연속으로 수행해도 각 컴포넌트는 필요한 경우에만 리렌더링되어야 한다\"</code> 테스트 코드 이 부분에서 <code class=\"language-text\">xpect(generateItemsSpy).toHaveBeenCalledTimes(1)</code>\n-> 2번 호출되는 이슈가 있었다.</p>\n<h4 id=\"-원인-분석-1\" style=\"position:relative;\"><a href=\"#-%EC%9B%90%EC%9D%B8-%EB%B6%84%EC%84%9D-1\" aria-label=\" 원인 분석 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🔍 원인 분석</h4>\n<p>Main.tsx에서 아래처럼 작성된 부분이 문제의 원인이었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token literal-property property\">Main</span><span class=\"token operator\">:</span> React<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>items<span class=\"token punctuation\">,</span> setItems<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token function\">generateItems</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>generateItems(1000) 이 부분이 useState에 전달되기 전에 즉시 실행된다.</p>\n</li>\n<li>\n<p>즉, Main 컴포넌트가 렌더링될 때마다 항상 새로운 배열을 생성하게 되는 것.</p>\n</li>\n<li>\n<p>그래서 React는 “이전 배열이랑 다르네”라고 생각해서 <strong>불필요한 리렌더</strong>가 생길 수 있게 되는 것이다..!</p>\n</li>\n</ul>\n<h4 id=\"-해결-방법-1\" style=\"position:relative;\"><a href=\"#-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-1\" aria-label=\" 해결 방법 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✅ 해결 방법</h4>\n<p>지연 초기화 방식 (Lazy initialization)을 사용해야 해결이 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token literal-property property\">Main</span><span class=\"token operator\">:</span> React<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>items<span class=\"token punctuation\">,</span> setItems<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token function\">generateItems</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>이렇게 해야 <code class=\"language-text\">generateItems(1000)</code>은 <strong>처음 렌더링할 때 딱 한 번만 실행된다</strong></p>\n</li>\n<li>\n<p>그 이후에는 이 함수는 실행되지 않고, 내부에 저장된 초기값만 사용된다.</p>\n</li>\n</ul>","frontmatter":{"title":"항해플러스 프론트엔드 5기 3주차 회고","date":"April 13, 2025","image":"https://velog.velcdn.com/images/chloeee/post/db477a29-3257-42ee-b936-58629e0ef09f/image.png"}}},"pageContext":{"slug":"/etc/hanghae-fe-5th-week3-retro/","previous":{"fields":{"slug":"/etc/hanghae-fe-5th-week2-retro/"},"frontmatter":{"title":"항해플러스 프론트엔드 5기_2주차 회고"}},"next":null}},"staticQueryHashes":["2486386679","3128451518"]}