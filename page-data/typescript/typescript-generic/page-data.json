{"componentChunkName":"component---src-templates-blog-post-js","path":"/typescript/typescript-generic/","result":{"data":{"site":{"siteMetadata":{"title":"Chloebo.io","author":"chloe bo kim","siteUrl":"https://bokim1004.github.io","comment":{"disqusShortName":"https-bokim1004-github-io","utterances":"bokim1004/blog-comments"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"d6963cac-0c1e-52e6-9084-1f97a2d09ee2","excerpt":"이펙티브 타입스크립트를 읽고 공부한 것을 기록합니다. 타입 중복은 코드 중복만큼 많은 문제를 일으킨다. 만약에 선택적 필드인 middleName을 Person에 추가한다고 가정해보자.\n그러면 Person과 PersonWithBirthDate은 다른 타입이 된다. 위 예제에서는 한 인터페이스가 다른 인터페이스를 확장하게 해서 반복을 제거하게 한다. 다음 예시로는 전체 애플리케이션의 상태를 표현하는 State타입과 단지 부분만 표현하는 TopNavState가 있는 경우가 있다. TopNavState…","html":"<blockquote>\n<p>이펙티브 타입스크립트를 읽고 공부한 것을 기록합니다.</p>\n</blockquote>\n<p>타입 중복은 코드 중복만큼 많은 문제를 일으킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  firstName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  lastName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">PersonWithBirthDate</span> <span class=\"token punctuation\">{</span>\n  firstName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  lastName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  birth<span class=\"token operator\">:</span> Date\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약에 선택적 필드인 middleName을 Person에 추가한다고 가정해보자.\n그러면 Person과 PersonWithBirthDate은 다른 타입이 된다.</p>\n<p>위 예제에서는 한 인터페이스가 다른 인터페이스를 확장하게 해서 반복을 제거하게 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  firstName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  lastName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">PersonWithBirthDate</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  birth<span class=\"token operator\">:</span> Date\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다음 예시로는 전체 애플리케이션의 상태를 표현하는 State타입과 단지 부분만 표현하는 TopNavState가 있는 경우가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">State</span> <span class=\"token punctuation\">{</span>\n  userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  pageTitle<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  recentFiles<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  pageContents<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">TopNavState</span> <span class=\"token punctuation\">{</span>\n  userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  pageTitle<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  recentFiles<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TopNavState를 확장하여 State를 구상하기 보다, State의 부분 집합으로 TopNavState를 정의하는 것이 바람직해 보인다.\n이 방법이 전체 앱의 상태를 하나의 인터페이스로 유지할 수 있게 해준다.\n<code class=\"language-text\">state를 인덱싱하여 속성의 타입에서 중복을 제거할 수 있다.</code></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TopNavState</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  userId<span class=\"token operator\">:</span> State<span class=\"token punctuation\">[</span><span class=\"token string\">'userId'</span><span class=\"token punctuation\">]</span>\n  pageTitle<span class=\"token operator\">:</span> State<span class=\"token punctuation\">[</span><span class=\"token string\">'pageTitle'</span><span class=\"token punctuation\">]</span>\n  recentFiles<span class=\"token operator\">:</span> State<span class=\"token punctuation\">[</span><span class=\"token string\">'recentFiles'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>State내의 pageTitle이 바뀌면 TopNavState에서도 반영된다. 그러나 여전히 반복되는 코드가 존재한다.\n이 때 ‘매핑된 타입’을 사용하면 좀 더 나아진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TopNavState</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>k <span class=\"token keyword\">in</span> <span class=\"token string\">'userId'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'pageTitle'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'recentFiles'</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> State<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>매핑된 타입은 배열의 필드를 루프도는 것과 같은 방식이다.</p>\n<p>정의가 완전하지는 않지만 다음과 같이 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Pick<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>k <span class=\"token keyword\">in</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TopNavState</span> <span class=\"token operator\">=</span> Pick<span class=\"token operator\">&lt;</span>State<span class=\"token punctuation\">,</span> <span class=\"token string\">'userId'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'pageTitle'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'recentFiles'</span><span class=\"token operator\">></span></code></pre></div>\n<p>여기서 Pick은 제너릭 타입이다.\n중복된 코드를 없앤다는 관점에서 pick을 사용하는 것은 함수를 호출하는 것에 비유할 수 있다.\n마치 함수에서 두 개의 매개변수 값을 받아서 결괏값을 반환하는 것처럼 Pick은 T,K 2가지 타입을 받아서 결과 타입을 반환한다.</p>\n<p>태그된 유니온에서도 다른 형태의 중복이 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">SaveAction</span> <span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'save'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">LoadAction</span> <span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'load'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Action</span> <span class=\"token operator\">=</span> SaveAction <span class=\"token operator\">|</span> LoadAction\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">ActionType</span> <span class=\"token operator\">=</span> <span class=\"token string\">'save'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'load'</span> <span class=\"token comment\">//타입 반복</span></code></pre></div>\n<p>Action유니온을 인덱싱하면 타입 반복없이 ActionType을 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">ActionType</span> <span class=\"token operator\">=</span> Action<span class=\"token punctuation\">[</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span><span class=\"token string\">'; // 타입은 '</span>save<span class=\"token string\">' | '</span>load'<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Action 유니온에 타입을 더 추가하면 ActionType은 자동적으로 그 타입을 포함한다.\nActionType은 Pick을 사용해 얻게되는 type속성을 가지는 인터페이스와는 다르다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">ActionRec</span> <span class=\"token operator\">=</span> Pick<span class=\"token operator\">&lt;</span>Action<span class=\"token punctuation\">,</span> <span class=\"token string\">'type'</span><span class=\"token operator\">></span> <span class=\"token comment\">// {type:\"save\" |\"load\"}</span></code></pre></div>\n<p>값의 형태에 해당되는 타입을 정의하고 싶을 때도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> InIT_OPTIONS <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  width<span class=\"token operator\">:</span> <span class=\"token number\">640</span><span class=\"token punctuation\">,</span>\n  height<span class=\"token operator\">:</span> <span class=\"token number\">480</span><span class=\"token punctuation\">,</span>\n  color<span class=\"token operator\">:</span> <span class=\"token string\">'#00fff'</span><span class=\"token punctuation\">,</span>\n  label<span class=\"token operator\">:</span> <span class=\"token string\">'VGA'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Options</span> <span class=\"token punctuation\">{</span>\n  width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n  height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n  color<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  label<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런 경우 typeof를 사용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Options</span> <span class=\"token operator\">=</span> typeOf <span class=\"token constant\">INIT_OPTIONS</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 코드는 자바스크립트의 런타임 연산자 typeof를 사용한 것처럼 보이지만, 실제로는 타입스크립트 단게에서 연산되며 훨씬 더 정확하게 타입을 표현한다.\n그런데 값으로부터 타입을 만들어 낼 때는 선언의 순서에 주의해야 한다. 타입 정의를 먼저하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">getUserInfo</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    userId<span class=\"token punctuation\">,</span>\n    name<span class=\"token punctuation\">,</span>\n    age<span class=\"token punctuation\">,</span>\n    height<span class=\"token punctuation\">,</span>\n    weight<span class=\"token punctuation\">,</span>\n    favoriteColor<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//추론된 반환타입은 {userId:string; name:string; age:number...}</span></code></pre></div>\n<p>표준 라이브러리에는 이러한 일반적 패턴의 제너릭 타입이 정의되어있다.\n이런 경우 ReturnType 제너릭이 정확히 들어맞는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">UserInfo</span> <span class=\"token operator\">=</span> ReturnType<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> getUserInfo<span class=\"token operator\">></span></code></pre></div>\n<p>ReturnType은 함수의 값인 getUserInfo가 아니라 함수의 타입인 <code class=\"language-text\">typeof getUserInfo</code>에 적용되었다.\ntypeof와 마찬가지로 이런 기법은 신중하게 사용해야 한다.\n적용 대상이 값인지 타입인지 정확히 알고 구분해서 처리해야 한다.</p>\n<p><code class=\"language-text\">Pick</code>의 정의는 extends를 사용해서 완성할 수 있다. 타입체커를 통해 기존 예제를 실행해보면 오류가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Pick<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>k <span class=\"token keyword\">in</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span>\n  <span class=\"token comment\">//~'K'타입은 'string | number | symbol' 타입에 할당할 수 없다.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>K는 T타입과 무관하고 범위가 너무 넓다. K는 인덱스로 사용될 수 있는 string | number | symbol이 되어야 하며 실제로는 범위를 조금 더 좁힐 수 있다.\nK는 실제로 T의 키의 부분 집합, 즉 keyof T가 되어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Pick<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span> <span class=\"token keyword\">extends</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>k <span class=\"token keyword\">in</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token comment\">//정상</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>타입이 값의 집합이라는 관점에서 생각하면 extends를 확장이 아니라 <code class=\"language-text\">부분 집합</code>이라는 걸 이해하는데 도움이 될 것이다.</p>\n<h4 id=\"요약\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h4>\n<ul>\n<li>타입들간의 매핑을 위해 타입스크립트가 제공한 도구들을 공부하면 좋다.\n여기에는 keyof, typeof,인덱싱, 매핑된 타입들이 포함된다.</li>\n<li>제너릭 타입은 타입을 위한 함수와 같다. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는 것이 좋다.\n제너릭 타입을 제한하려면 extends를 사용하면 된다.</li>\n<li>표준 라이브러리에 정의된 <code class=\"language-text\">pick,Partial,ReturnType</code>같은 제너릭 타입에 익숙해져야 한다.</li>\n</ul>","frontmatter":{"title":"타입 연산과 제너릭 사용으로 반복을 줄이기","date":"November 10, 2022","image":null}}},"pageContext":{"slug":"/typescript/typescript-generic/","previous":{"fields":{"slug":"/typescript/interface-and-type/"},"frontmatter":{"title":"타입과 인터페이스의 차이점 알기"}},"next":{"fields":{"slug":"/typescript/index-signature/"},"frontmatter":{"title":"동적 데이터에 인덱스 시그니처 사용하기"}}}},"staticQueryHashes":["2486386679","3128451518"]}