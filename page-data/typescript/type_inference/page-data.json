{"componentChunkName":"component---src-templates-blog-post-js","path":"/typescript/type_inference/","result":{"data":{"site":{"siteMetadata":{"title":"chloe's tech blog","author":"chloe kim","siteUrl":"https://bokim1004.github.io","comment":{"disqusShortName":"https-bokim1004-github-io","utterances":"bokim1004/blog-comments"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"05c058f2-7fdd-5c4d-adee-b171d3071e97","excerpt":"타입추론 타입스크립트는 타입 추론을 적극적으로 수행한다.\n타입추론은 수동으로 명시해야하는 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 추론 가능한 타입을 사용해 장황한 코드 방지하기 보통 타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론된다.\n다음 예제에서 express HTTP 서버 라이브러리를 사용하는 request와 reponse…","html":"<h2 id=\"타입추론\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%B6%94%EB%A1%A0\" aria-label=\"타입추론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입추론</h2>\n<p>타입스크립트는 타입 추론을 적극적으로 수행한다.\n타입추론은 수동으로 명시해야하는 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다.</p>\n<h3 id=\"추론-가능한-타입을-사용해-장황한-코드-방지하기\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EB%A1%A0-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%9E%A5%ED%99%A9%ED%95%9C-%EC%BD%94%EB%93%9C-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0\" aria-label=\"추론 가능한 타입을 사용해 장황한 코드 방지하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추론 가능한 타입을 사용해 장황한 코드 방지하기</h3>\n<p>보통 타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론된다.\n다음 예제에서 express HTTP 서버 라이브러리를 사용하는 request와 reponse타입 선언은 필요하지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 이렇게 하지 맙시다.</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/health'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token literal-property property\">request</span><span class=\"token operator\">:</span> express<span class=\"token punctuation\">.</span>Request<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">response</span><span class=\"token operator\">:</span> express<span class=\"token punctuation\">.</span>Response</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  response<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'OK'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">//이렇게 합시다.</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/health'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">request<span class=\"token punctuation\">,</span> response</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  response<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'OK'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>타입스크립트가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는게 좋다.</li>\n<li>추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다. 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해준다.</li>\n</ul>\n<h4 id=\"다른-타입에는-다른-변수-사용하기\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%A5%B8-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%EB%8B%A4%EB%A5%B8-%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"다른 타입에는 다른 변수 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다른 타입에는 다른 변수 사용하기</h4>\n<p>자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 된다.\n그러나 타입스크립트에서는 두 가지 오류가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> id <span class=\"token operator\">=</span> <span class=\"token string\">'12-34-56'</span>\n<span class=\"token function\">fetchProduct</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\nid <span class=\"token operator\">=</span> <span class=\"token number\">123456</span>\n<span class=\"token comment\">//'123456'형식은 string형식에 할당할 수 없다.</span>\n<span class=\"token function\">fetchProductBySerialNumber</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//string형식의 인수는 number형식의 매개변수에 할당될 수 없다.</span></code></pre></div>\n<p>타입스크립트는 ‘12-34-56’이라는 값을 보고, id의 타입을 string으로 추론했다.\nstring타입에는 number타입을 할당할 수 없기에 오류가 발생한다.</p>\n<p>여기서 변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다는 걸 알 수 있다.\n타입을 바꿀 수 있는 한가지 방법은 범위를 좁히는 것인데, 새로운 변수 값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것이다.</p>\n<p>id의 타입을 바꾸지 않으려면, string과 number를 모두 포함할 수 있도록 타입을 확장하면 된다.\n<code class=\"language-text\">string | number</code>로 표현하며 유니온타입이라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> id<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token string\">'12-34-56'</span>\n<span class=\"token function\">fetchProduct</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\nid <span class=\"token operator\">=</span> <span class=\"token number\">123456</span> <span class=\"token comment\">// 정상</span>\n<span class=\"token function\">fetchProductBySerialNumber</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span> <span class=\"token comment\">//정상</span></code></pre></div>\n<p>타입스크립트는 첫 번째 함수 호출에서 id는 string으로, 두 번째 호출에서는 number라고 제대로 판단한다.\n할당문에서 유니온 타입으로 범위가 좁혀졌기 때문이다.</p>\n<p>유니온 타입으로 코드가 동작하긴 하겠지만 더 많은 문제가 생길 수 있다.\nid를 사용할 때마다 값이 어떤 타입인지 확인해야하기에 유니온 타입은 string이나 number같은 간단한 타입에 비해 다루기 더 어렵다.\n차라리 별도의 변수를 도입하는 것이 낫다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token string\">'12-34-56'</span>\n<span class=\"token function\">fetchProduct</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> serial <span class=\"token operator\">=</span> <span class=\"token number\">123456</span>\n<span class=\"token function\">fetchProductBySerialNumber</span><span class=\"token punctuation\">(</span>serial<span class=\"token punctuation\">)</span></code></pre></div>\n<p>다른 타입에는 별도의 변수를 사용하는게 바람직한 이유는 다음과 같다.</p>\n<ul>\n<li>서로 관련이 없는 두 개의 값을 분리한다.</li>\n<li>변수명을 더 구체적으로 지을 수 있다.</li>\n<li>타입 추론을 향상시키며, 타입 구문이 불필요해진다.</li>\n<li>타입이 좀 간결해진다.</li>\n<li>let 대신 const로 변수를 선언하게 된다. const로 변수를 선언하면 코드가 간결해지고, 타입체커가 타입을 추론하기에도 좋다.</li>\n</ul>\n<p><code class=\"language-text\">타입이 바뀌는 변수는 되도록 피해야 하고, 목적이 다른 곳에는 별도의 변수명을 사용해야 한다.</code></p>\n<h4 id=\"타입-넓히기\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EB%84%93%ED%9E%88%EA%B8%B0\" aria-label=\"타입 넓히기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 넓히기</h4>\n<p>상수를 사용해서 변수를 초기화할 때, 타입을 명시하지 않으면 타입체커는 타입을 결정해야 한다.\n이 말은 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻이다.</p>\n<p>타입스크립트에서는 이러한 과정을 <code class=\"language-text\">넓히기</code>라고 한다.\n넓히기의 과정을 이해한다면 오류의 원인을 파악하고 타입 구문을 더 효과적으로 사용할 수 있을 것이다.</p>\n<p>타입 넓히기가 진행될 때, 주어진 값으로 추론 가능한 타입이 여러 개이기에 과정이 상당히 모호하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> mixed <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'x'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>정보가 충분하지 않다면 mixed가 어떤 타입으로 추론되어야 하는지 알 수 없다.</p>\n<p>타입스크립트는 넓히기의 과정을 제어할 수 있도록 몇 가지 방법을 제공한다.\n넓히기 과정을 제어할 수 있는 첫 번째 방법은 <code class=\"language-text\">const</code>다. 만약 let대신 const로 변수를 선언하면 더 좁은 타입이 된다.</p>\n<p>그러나 const는 만능이 아니다. 객체와 배열의 경우에는 여전히 문제가 있다.\n아이템 초반에 있는 mixed 예제(<code class=\"language-text\">const mixed = ['x', 1]</code>)는 배열에 대한 문제를 보여준다.\n튜플 타입을 추론해야할지, 요소들은 어떤 타입으로 추론해야할지 알 수 없다.</p>\n<p>타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의해야 한다.\n<code class=\"language-text\">타입스크립트의 기본 동작을 재정의하는 세 가지 방법</code>이 있다.</p>\n<ol>\n<li>명시적 타입 구문을 제공하는 것이다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> v<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">3</span> <span class=\"token operator\">|</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// 타입이 {x: 1|3|5; }</span></code></pre></div>\n<ol start=\"2\">\n<li>타입 체커에 추가적인 문맥을 제공하는 것이다.</li>\n<li>const 단언문을 사용하는 것이다. const단언문과 변수 선언에 쓰이는 let이나 const와 혼동해서는 안된다.\nconst 단언문은 온전히 타입 공간의 기법이다. 다음 예제를 통해 각 변수에 추론된 타입의 차이점을 살펴보자.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> v1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  y<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">//타입은 {x:number; y:number; }</span>\n<span class=\"token keyword\">const</span> v2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">,</span>\n  y<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// 타입은 {x:1, y:number}</span></code></pre></div>\n<p>값 뒤에 <code class=\"language-text\">as const</code>를 작성하면 타입스크립트는 최대한 좁은 타입으로 추론된다.\n또한 배열을 튜플 타입으로 추론할 때도 as const를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> a1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 타입이 number[]</span>\n<span class=\"token keyword\">const</span> a2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span> <span class=\"token comment\">// 타입이 readonly[1,2,3]</span></code></pre></div>\n<ul>\n<li>타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 방법을 이해해야 한다.</li>\n<li>동작에 영향을 줄 수 있는 방법인 const,타입 구문, 문맥,as const에 익숙해져야 한다.</li>\n</ul>\n<h4 id=\"타입-좁히기\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EC%A2%81%ED%9E%88%EA%B8%B0\" aria-label=\"타입 좁히기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 좁히기</h4>\n<p>타입 좁히기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.\n가장 일반적인 예시는 null체크다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> el <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//타입이 HTMLElement | null</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  el <span class=\"token comment\">//타입이 HTMLElement</span>\n  el<span class=\"token punctuation\">.</span>innerHTML  <span class=\"token operator\">=</span> 'Party Time\"<span class=\"token punctuation\">.</span><span class=\"token function\">blink</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  el <span class=\"token comment\">// 타입이 null</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'No element #foo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 el이 null이면 분기문의 첫 번째 블록이 실행되지 않는다.\n첫번째 블록에서 HTMLElement | null 타입의 null을 제외하므로, 더 좁은 타입이 되어 작업이 훨씬 쉬워진다.</p>\n<p><code class=\"language-text\">Array.isArray</code>같은 일부 내장 함수로도 타입을 좁힐 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>text<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> terms<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> termList <span class=\"token operator\">=</span> <span class=\"token builtin\">Array</span><span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>terms<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> terms <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>terms<span class=\"token punctuation\">]</span>\n  termList <span class=\"token comment\">// 타입이 string[]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">타입스크립트는 일반적으로 조건문에서 타입을 좁히는데 매우 능숙하다</code>\n그러나 타입을 섣불리 판단하는 실수를 저지르기 쉬우므로 다시 한번 꼼꼼히 따져봐야 한다.\n예를 들어 다음 예제는 유니온 타입에서 null을 제외하기 위해 잘못된 방법을 사용했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> el <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 타입이 HTMLElement | null</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> el <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  el <span class=\"token comment\">// 타입이 HTMLElement | null</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>자바스크립트에서는 typeof null이 <code class=\"language-text\">object</code>이기에 if구문에서 null이 제외되지 않았다.</p>\n<p>타입스크립트가 타입을 식별하지 못한다면 식별을 돕기 위해 커스텀 함수를 도입할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">isInputElement</span><span class=\"token punctuation\">(</span>el<span class=\"token operator\">:</span> HTMLElement<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> el <span class=\"token keyword\">is</span> HTMLInputElement <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'value'</span> <span class=\"token keyword\">in</span> el\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getElementContent</span><span class=\"token punctuation\">(</span>el<span class=\"token operator\">:</span> HTMLElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isInputElement</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    el <span class=\"token comment\">// 타입이 HTMLInputElement</span>\n    <span class=\"token keyword\">return</span> el<span class=\"token punctuation\">.</span>value\n  <span class=\"token punctuation\">}</span>\n  el <span class=\"token comment\">// 타입이 HTMLElement</span>\n  <span class=\"token keyword\">return</span> el<span class=\"token punctuation\">.</span>textContent\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이러한 기법은 <code class=\"language-text\">사용자 정의 타입 가드</code>라고 한다.\n반환 타입의 el is HTMLInputElement는 함수 반환이 true인 경우, 타입 체커에서 매개변수의 타입을 좁힐 수 있다고 알려준다.</p>\n<p>타입스크립트에서 타입이 어떻게 좁혀지는지 이해한다면 타입추론에 대한 개념을 잡을 수 있고, 오류 발생의 원인을 알 수 있으며 타입 체커를 더 효율적으로 할 수 있다.</p>\n<h4 id=\"비동기-코드에는-콜백대신-async-함수-사용하기\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BD%94%EB%93%9C%EC%97%90%EB%8A%94-%EC%BD%9C%EB%B0%B1%EB%8C%80%EC%8B%A0-async-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"비동기 코드에는 콜백대신 async 함수 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기 코드에는 콜백대신 async 함수 사용하기</h4>\n<p>과거의 자바스크립트에서는 비동기 동작을 모델링하기 위해 콜백을 사용했다.\n그렇기에 악명 높은 콜백 지옥을 필연적으로 마주할 수밖에 없었다.</p>\n<p>콜백이 중첩된 코드는 직관적으로 이해하기 어렵다. 요청들을 병렬로 실행하거나 오류 상황을 빠져나오고 싶다면 더욱 혼란스러워진다.\nES2015는 콜백 지옥을 극복하기 위해 프로미스 개념을 도입했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> page1Promise <span class=\"token operator\">=</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url1<span class=\"token punctuation\">)</span>\npage1Promise\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>response1<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url2<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>response2<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url3<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>response3<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>코드의 중첩도 적어졌고 실행순서도 코드 순서와 같아졌다.\nES2017에서는 <code class=\"language-text\">async await </code>키워드를 도입하여 콜백 지옥을 더욱 간단하게 처리할 수 있게 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchPages</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> response1 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url1<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> response2 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url2<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> response3 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url3<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>await 키워드는 각각의 프로미스가 처리될 때까지 fetchPages함수의 실행을 멈춘다.\nasync함수 내에서 await중인 프로미스가 거절되면 예외를 던진다.\n이를 통해 일반적인 try/catch구문을 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchPages</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response1 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url1<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> response2 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url2<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> response3 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url3<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>콜백보다는 프로미스나 async/await을 사용해야하는 이유는 다음과 같다</p>\n<ul>\n<li>콜백보다는 프로미스가 코드를 작성하기 쉽다.</li>\n<li>콜백보다는 프로미스가 타입을 추론하기 쉽다.</li>\n</ul>\n<p>예를 들어, 병렬로 페이지를 로드하고 싶다면 <code class=\"language-text\">Promise.all</code>을 사용해서 프로미스를 조합하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchPages</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>response1<span class=\"token punctuation\">,</span> response2<span class=\"token punctuation\">,</span> response3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token builtin\">Promise</span><span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n    <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일반적으로 프로미스를 생성하기 보다 async/await을 사용해야 한다.</p>\n<ul>\n<li>일반적으로 더 간결하고 직관적인 코드가 된다.</li>\n<li>async함수는 항상 프로미스를 반환하도록 강제한다.</li>\n</ul>","frontmatter":{"title":"타입 추론","date":"December 14, 2022","image":"https://velog.velcdn.com/images/chloeee/post/39563e2c-9400-4099-b125-7382c076ae1d/image.png"}}},"pageContext":{"slug":"/typescript/type_inference/","previous":{"fields":{"slug":"/javascript/promise_and_async-await/"},"frontmatter":{"title":"Promise와 async await"}},"next":{"fields":{"slug":"/react/jest/"},"frontmatter":{"title":"TDD(테스트 주도 개발)과 jest에 대하여"}}}},"staticQueryHashes":["2486386679","3128451518"]}