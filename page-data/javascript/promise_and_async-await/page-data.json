{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/promise_and_async-await/","result":{"data":{"site":{"siteMetadata":{"title":"Chloebo.io","author":"chloe bo kim","siteUrl":"https://bokim1004.github.io","comment":{"disqusShortName":"https-bokim1004-github-io","utterances":"bokim1004/blog-comments"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"32377b88-84eb-503e-95e1-29e5544f8d6d","excerpt":"회사에서 처음으로 코드리뷰 시간이 있었다.\n맨날 급하게 개발해야한다는 핑계로 너무 생각없이 코드를 짠 부분이 보여서 부끄러웠다.\n아래와 같이 api를 호출하기 위해 useEffect를 사용했다.\n이 코드에는 이 있었다. 1. 왜 프로미스와 async await을 혼용하였는가? 다른 개발자분께서 위 코드는 async await이 적용 안되었을 것 같아 보이네요 라고 말씀하셨다. \nasync await…","html":"<p>회사에서 처음으로 코드리뷰 시간이 있었다.<br/>\n맨날 급하게 개발해야한다는 핑계로 너무 생각없이 코드를 짠 부분이 보여서 부끄러웠다.<br/>\n아래와 같이 api를 호출하기 위해 useEffect를 사용했다.\n이 코드에는 <code class=\"language-text\">크게 2가지 문제점</code>이 있었다.</p>\n<p align=\"center\">\n<img src=\"https://velog.velcdn.com/images/chloeee/post/0a28ca6a-b5e9-4e4e-8207-b2e5c2c077cc/image.png\" width=\"500px\">\n</p>\n<h4 id=\"1-왜-프로미스와-async-await을-혼용하였는가\" style=\"position:relative;\"><a href=\"#1-%EC%99%9C-%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4%EC%99%80-async-await%EC%9D%84-%ED%98%BC%EC%9A%A9%ED%95%98%EC%98%80%EB%8A%94%EA%B0%80\" aria-label=\"1 왜 프로미스와 async await을 혼용하였는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 왜 프로미스와 async await을 혼용하였는가?</h4>\n<p>다른 개발자분께서 위 코드는 async await이 적용 안되었을 것 같아 보이네요 라고 말씀하셨다. <br/>\nasync await을 사용하는 이유는 프로미스를 더 편하게 사용하기 위함이다.\n이 둘의 차이를 정확히 알고 썼어야 했다.</p>\n<h4 id=\"2-왜-then에서-e로-값을-받고-있는가\" style=\"position:relative;\"><a href=\"#2-%EC%99%9C-then%EC%97%90%EC%84%9C-e%EB%A1%9C-%EA%B0%92%EC%9D%84-%EB%B0%9B%EA%B3%A0-%EC%9E%88%EB%8A%94%EA%B0%80\" aria-label=\"2 왜 then에서 e로 값을 받고 있는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 왜 then에서 e로 값을 받고 있는가?</h4>\n<p>보통 then에서는 값을 받게 되니까 res,response를 작성한다.\n보통 catch에서 에러나는 부분을 e,error로 받는다.\n이 부분을 전혀 생각하지도 않고 쓰고 있었다고 한다…</p>\n<br/>\n<blockquote>\n<p>이번을 계기로 promise와 async await의 차이점을 구체적으로 알고 잘 적용해야겠다는 생각이 들어 공부를 해보았다.</p>\n</blockquote>\n<h3 id=\"promise\" style=\"position:relative;\"><a href=\"#promise\" aria-label=\"promise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise?</h3>\n<p>프로미스는 자바스크립트 비동기 처리에 사용되는 객체이다.\n싱글스레드인 자바스크립트에서 <code class=\"language-text\">비동기 처리를 위해 사용한 callback함수의 예외,에러처리에 대한 어려움, 중첩으로 인한 복잡도 증가라는 &lt;br/> 단점을 해결</code>하기 위해 프로미스 객체를 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//executor</span>\n  <span class=\"token comment\">//  비동기 작업 성공하면 resolve()를 호출하고</span>\n  <span class=\"token comment\">//비동기 작업 실패시 reject()를 호출하도록 구현한다.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//처리 내용</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\npromise\n  <span class=\"token punctuation\">.</span>then\n  <span class=\"token comment\">//resolve가 호출되면 then이 실행</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span>catch\n  <span class=\"token comment\">//reject가 호출되면 catch 실행</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span>finally\n  <span class=\"token comment\">//콜백 작업 마치고 무조건 실행 (생략 가능함)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">new Promise</code>에 전달되는 함수는 executor(실행자,실행함수)라고 부른다.\nexcutor는 <code class=\"language-text\">new Promise</code>가 만들어질 때 자동으로 실행되는데 결과를 최종적으로 만들어내는 제작 코드를 포함한다.\nexcutor의 인수 <code class=\"language-text\">resolve</code>와 <code class=\"language-text\">reject</code>는 자바스크립트에서 자체 제공하는 콜백이다.\nexecutor에선 결과를 즉시 얻든 늦게 얻든 상관없이, 상황에 따라 인수로 넘겨준 콜백 중 하나를 반드시 호출해야 한다.</p>\n<p><code class=\"language-text\"> resolve(value)</code>: 일이 성공적으로 끝난 경우 그 결과를 value와 함께 호출한다.\n<code class=\"language-text\">reject(error)</code>: 에러발생 시 에러 객체를 나타내는 error와 함께 호출</p>\n<p>다시 말해, excutor는 자동으로 실행되는데 여기서 원하는 일이 처리된다.\n처리가 끝나면 excutor는 처리 성공여부에 따라 <code class=\"language-text\">resolve</code>,<code class=\"language-text\">reject</code>를 호출한다.</p>\n<h4 id=\"promise의-3가지-상태\" style=\"position:relative;\"><a href=\"#promise%EC%9D%98-3%EA%B0%80%EC%A7%80-%EC%83%81%ED%83%9C\" aria-label=\"promise의 3가지 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise의 3가지 상태</h4>\n<p>여기서 상태란 프로미스의 처리과정을 의미\n<code class=\"language-text\">new Promise()</code>로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖는다.</p>\n<p align=\"center\">\n<img src=\"https://velog.velcdn.com/images/chloeee/post/39c6996f-9669-4589-bfba-d12570a93a5b/image.png\" width=\"500px\">\n</p>\n<ol>\n<li><code class=\"language-text\">Pending(대기)</code> :비동기 처리 로직이 아직 완료되지 않은 상태</li>\n</ol>\n<ul>\n<li>new Promise()를 호출하면 대기 상태가 됨\n<br/></li>\n</ul>\n<ol start=\"2\">\n<li>\n<p><code class=\"language-text\">Fulfilled(이행)</code> : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태</p>\n</li>\n<li>\n<p><code class=\"language-text\">Rejected(실패)</code>: 비동기 처리가 실패하거나 오류가 발생한 상태</p>\n</li>\n</ol>\n<p>이행(resolved) 혹은 거부(rejected)상태의 프로미스는 <code class=\"language-text\">처리된 settled 프로미스</code>라고 부른다.</p>\n<h4 id=\"소비자thencatchfinally\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EB%B9%84%EC%9E%90thencatchfinally\" aria-label=\"소비자thencatchfinally permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소비자:then,catch,finally</h4>\n<p>프로미스 객체는 executor(제작코드)와 결과나 에러를 받을 소비함수를 이어주는 역할을 한다.\n소비함수는 <code class=\"language-text\">.then, .catch, .finally</code> 메서드를 사용해 등록된다.</p>\n<h4 id=\"then\" style=\"position:relative;\"><a href=\"#then\" aria-label=\"then permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>then</h4>\n<p><code class=\"language-text\">.then</code>은 프로미스에서 가장 중요하고 기본이 되는 메서드다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//결과를 다룬다.</span>\n<span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//에러를 다룬다.</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">.then</code>의 첫번째 인수는 프로미스가 이행되었을 때 실행되는 함수이고, 여기서 실행결과를 받는다.</li>\n<li><code class=\"language-text\">.then</code>의 두 번째 인수는 프로미스가 거부되었을 때 실행되는 함수이고, 여기서 에러를 받는다.</li>\n<li>작업이 성공적으로 처리된 경우만 다루고 싶다면 <code class=\"language-text\">.then</code>에 인수를 하나만 전달하면 된다.</li>\n</ul>\n<h4 id=\"catch\" style=\"position:relative;\"><a href=\"#catch\" aria-label=\"catch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>catch</h4>\n<p>에러가 발생한 경우만 다루고 싶다면 <code class=\"language-text\">.then(null, errorHandlingFunction)</code>같이 null을 첫번째 인수로 전달하면 된다.\n<code class=\"language-text\">.catch(errorHandlingFunction)</code>를 써도 되는데 <code class=\"language-text\">.catch</code>는 <code class=\"language-text\">.then</code>에 null을 전달하는 것과 동일하게 작동한다.\n<code class=\"language-text\">.catch(f)</code>는 문법이 간결하다는 점만 빼고 <code class=\"language-text\">.then(null,f)</code>과 완벽하게 같다.</p>\n<h4 id=\"finally\" style=\"position:relative;\"><a href=\"#finally\" aria-label=\"finally permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>finally</h4>\n<p>프라미스가 처리되면(이행이나 거부) f가 항상 실행된다는 점에서 <code class=\"language-text\">.finally(f) 호출은 .then(f, f)</code>과 유사하다.</p>\n<p>쓸모가 없어진 로딩 인디케이터(loading indicator)를 멈추는 경우같이, 결과가 어떻든 마무리가 필요하면 finally가 유용하다.</p>\n<p>그런데 <code class=\"language-text\">finally</code>는 <code class=\"language-text\">.then(f, f)</code>과 완전히 유사하지는 않다.</p>\n<ol>\n<li>finally핸들러엔 인수가 없다. 그래서 여기에선 프로미스가 이행되었는지, 거부되었는지 알 수 없다.\nfinally에선 절차를 마무리하는 보편적 동작을 수행하기에 성공,실패여부를 몰라도 된다.</li>\n<li>finally핸들러는 자동으로 다음 핸들러에 결과와 에러를 전달한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'결과'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">finally</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'프라미스가 준비되었습니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//// &lt;-- .then에서 result를 다룰 수 있음</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'에러 발생!'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">finally</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'프라미스가 준비되었습니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// &lt;-- .catch에서 에러 객체를 다룰 수 있음</span></code></pre></div>\n<p>finally는 프라미스 결과를 처리하기 위해 만들어 진 게 아니다.\n프라미스 결과는 finally를 통과해서 전달된다.. 이런 특징은 아주 유용하게 사용되기도 함!</p>\n<ol start=\"3\">\n<li><code class=\"language-text\">.finally(f)</code>는 함수 f를 중복해서 쓸 필요가 없기 때문에 <code class=\"language-text\">.then(f, f)</code>보다 문법 측면에서 더 편리하다.</li>\n</ol>\n<blockquote>\n<p>참고 : <a href=\"https://ko.javascript.info/promise-basics\">https://ko.javascript.info/promise-basics</a> , <a href=\"https://hi-zini.tistory.com/entry/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81-%EB%B0%A9%EC%8B%9D-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95-Callback-Promise-async-await\">https://hi-zini.tistory.com/entry/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81-%EB%B0%A9%EC%8B%9D-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95-Callback-Promise-async-await</a></p>\n</blockquote>","frontmatter":{"title":"프로미스와 async await","date":"November 15, 2022","image":null}}},"pageContext":{"slug":"/javascript/promise_and_async-await/","previous":{"fields":{"slug":"/typescript/index-signature/"},"frontmatter":{"title":"동적 데이터에 인덱스 시그니처 사용하기"}},"next":{"fields":{"slug":"/typescript/type_inference/"},"frontmatter":{"title":"type_inference"}}}},"staticQueryHashes":["2486386679","3128451518"]}